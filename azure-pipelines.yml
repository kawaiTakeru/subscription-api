# subscription-api / azure-pipelines.yml  (FIXED)
trigger: none
pr: none

pool:
  vmImage: windows-latest

variables:
  # System.Debug ON
  - name: System.Debug
    value: 'true'

  # 生成するサブスクリプションのワークロード
  - name: WORKLOAD
    value: 'Production'   # or 'DevTest'

  # エイリアス名の接頭辞（テナント内で一意になるように時刻サフィックス付与）
  - name: ALIAS_PREFIX
    value: 'crpoc'

# =========================================================
# Stage0: Subscription (Create via Azure CLI; then optional TF import)
# =========================================================
stages:
- stage: stage0_subscription
  displayName: "Stage0 - Create Subscription (Alias via CLI)"
  jobs:
  - job: create_alias
    displayName: "Probe billing + Create alias (CLI) + (optional) TF import"
    steps:
    - checkout: self

    - task: AzureCLI@2
      displayName: "WHOAMI / RBAC / Billing probes + Alias create"
      inputs:
        azureSubscription: 'snp-pipeline-api'   # Service connection name
        scriptType: pscore                      # PowerShell Core (UTF-8)
        scriptLocation: inlineScript
        inlineScript: |
          $ErrorActionPreference = 'Stop'
          $ProgressPreference    = 'SilentlyContinue'
          [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
          [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
          $env:PYTHONIOENCODING = 'utf-8'

          function Get-Json($url) {
            $out = az rest --method get --url $url --only-show-errors -o json 2>$null
            if (-not $out) { throw "az rest failed: $url" }
            return ($out | ConvertFrom-Json)
          }

          Write-Host "== WHOAMI =="
          $account  = az account show --only-show-errors -o json | ConvertFrom-Json
          $appId    = $account.user.name
          $tenantId = $account.tenantId
          Write-Host "tenantId : $tenantId"
          Write-Host "appId    : $appId"

          $sp = az ad sp show --id $appId --only-show-errors -o json | ConvertFrom-Json
          $spObjId = $sp.id
          Write-Host "spObjId  : $spObjId"
          Write-Host ""

          # （参考）現在のRBAC
          Write-Host "== RBAC at root (reference) =="
          az role assignment list --assignee $appId --all -o table --only-show-errors
          Write-Host ""

          $api = "2024-04-01"
          $found = @()
          $accs = $null

          # Billing accounts
          try {
            $accs = (Get-Json "https://management.azure.com/providers/Microsoft.Billing/billingAccounts?api-version=$api").value
          } catch {
            throw "Cannot list billingAccounts. Likely missing Billing Account reader permission."
          }
          if (-not $accs -or $accs.Count -eq 0) { throw "No billingAccounts visible. Missing permissions." }

          foreach ($acc in $accs) {
            $accName = $acc.name
            $accDisp = $acc.properties.displayName
            Write-Host ">> BillingAccount: $accDisp (name=$accName)"

            # Roles at Billing Account
            $rolesA = (Get-Json "https://management.azure.com/providers/Microsoft.Billing/billingAccounts/$accName/billingRoleAssignments?api-version=$api").value
            if ($rolesA) {
              $mineA  = $rolesA | Where-Object { $_.properties.principalId -eq $spObjId } | ForEach-Object {
                [PSCustomObject]@{ Scope="BillingAccount"; ScopeName=$accName; RoleDefinitionId=$_.properties.roleDefinitionId; PrincipalId=$_.properties.principalId }
              }
              if ($mineA) { $found += $mineA }
            }

            # Billing Profiles
            $profiles = (Get-Json "https://management.azure.com/providers/Microsoft.Billing/billingAccounts/$accName/billingProfiles?api-version=$api").value
            foreach ($p in ($profiles | ForEach-Object { $_ })) {
              $pname = $p.name
              $pdisp = $p.properties.displayName
              Write-Host "   - BillingProfile: $pdisp (name=$pname)"

              $rolesP = (Get-Json "https://management.azure.com/providers/Microsoft.Billing/billingAccounts/$accName/billingProfiles/$pname/billingRoleAssignments?api-version=$api").value
              if ($rolesP) {
                $mineP  = $rolesP | Where-Object { $_.properties.principalId -eq $spObjId } | ForEach-Object {
                  [PSCustomObject]@{ Scope="BillingProfile"; ScopeName="$accName/$pname"; RoleDefinitionId=$_.properties.roleDefinitionId; PrincipalId=$_.properties.principalId }
                }
                if ($mineP) { $found += $mineP }
              }

              # Invoice Sections
              $invoices = (Get-Json "https://management.azure.com/providers/Microsoft.Billing/billingAccounts/$accName/billingProfiles/$pname/invoiceSections?api-version=$api").value
              foreach ($iv in ($invoices | ForEach-Object { $_ })) {
                $ivname = $iv.name
                $ivdisp = $iv.properties.displayName
                Write-Host "       * InvoiceSection: $ivdisp (name=$ivname)"

                $rolesI = (Get-Json "https://management.azure.com/providers/Microsoft.Billing/billingAccounts/$accName/billingProfiles/$pname/invoiceSections/$ivname/billingRoleAssignments?api-version=$api").value
                if ($rolesI) {
                  $mineI  = $rolesI | Where-Object { $_.properties.principalId -eq $spObjId } | ForEach-Object {
                    [PSCustomObject]@{ Scope="InvoiceSection"; ScopeName="$accName/$pname/$ivname"; RoleDefinitionId=$_.properties.roleDefinitionId; PrincipalId=$_.properties.principalId }
                  }
                  if ($mineI) { $found += $mineI }
                }
              }
            }
          }

          Write-Host ""
          Write-Host "== Billing role assignments for this service principal =="
          if ($found.Count -gt 0) {
            $found | Sort-Object Scope, ScopeName | Format-Table -AutoSize
          } else {
            Write-Error "No billing roles found at any scope (Account/Profile/InvoiceSection)."
          }

          $invoiceRoles = $found | Where-Object { $_.Scope -eq "InvoiceSection" }
          if (-not $invoiceRoles -or $invoiceRoles.Count -eq 0) {
            throw "No role at InvoiceSection scope. Subscription creation via alias will fail."
          }

          # ---------- Create a subscription via Alias (create only) ----------
          Write-Host ""
          Write-Host "== Alias Create =="

          # Pick the first InvoiceSection we found (ScopeName is '<billingAccount>/<billingProfile>/<invoiceSection>')
          $targetScopeName = $invoiceRoles[0].ScopeName
          $parts = $targetScopeName -split '/'
          if ($parts.Count -ne 3) { throw "Unexpected ScopeName format: $targetScopeName" }

          $billingScope = "/providers/Microsoft.Billing/billingAccounts/$($parts[0])/billingProfiles/$($parts[1])/invoiceSections/$($parts[2])"
          Write-Host "Using billingScope: $billingScope"

          $aliasPrefix = "${env:ALIAS_PREFIX}"
          if (-not $aliasPrefix) { $aliasPrefix = "crpoc" }
          $timestamp = Get-Date -Format "yyyyMMddHHmmss"
          $aliasName = "$aliasPrefix-$timestamp"
          $displayName = "poc-$timestamp"
          $workload = "${env:WORKLOAD}"
          if (-not $workload) { $workload = "Production" }

          Write-Host "Creating alias: $aliasName  (displayName: $displayName, workload: $workload)"
          $createJson = az account alias create `
            --name $aliasName `
            --billing-scope $billingScope `
            --display-name $displayName `
            --workload $workload `
            -o json --only-show-errors | ConvertFrom-Json

          $subId = $createJson.properties.subscriptionId
          $state = $createJson.properties.provisioningState
          Write-Host "SubscriptionId: $subId"
          Write-Host "ProvisioningState: $state"

          # Poll
          for ($i=0; $i -lt 10; $i++) {
            Start-Sleep -Seconds 6
            $show = az account alias show -n $aliasName -o json --only-show-errors | ConvertFrom-Json
            $state = $show.properties.provisioningState
            Write-Host "  Poll[$i] state: $state"
            if ($state -eq "Succeeded") { break }
          }

          if ($state -ne "Succeeded") {
            Write-Warning "Alias provisioning state is '$state'."
          } else {
            Write-Host "Alias provisioning succeeded."
          }

          # 出力（後段に渡す）
          Write-Host "##vso[task.setvariable variable=subscriptionId;isOutput=true]$subId"
          Write-Host "##vso[task.setvariable variable=subscriptionAlias;isOutput=true]$aliasName"

    # （任意）作った Alias を Terraform state に取り込みだけ行う（plan/applyはしない）
    - task: PowerShell@2
      displayName: "(optional) Terraform import alias resource"
      condition: succeeded()    # 失敗しても後段には影響させないなら "always()" に変更可
      inputs:
        targetType: 'inline'
        script: |
          $ErrorActionPreference = 'Continue'
          $stageDir = "$(Build.SourcesDirectory)\terraform\stage0-subscription"
          $alias    = "$(create_alias.subscriptionAlias)"
          if ([string]::IsNullOrWhiteSpace($alias)) {
            Write-Host "No alias output. Skip import."
            exit 0
          }
          if (-not (Test-Path -LiteralPath $stageDir)) {
            Write-Host "No stage0-subscription dir. Skip import."
            exit 0
          }
          Push-Location $stageDir
          try {
            terraform -version | Out-Null
          } catch {
            # 最低限のインストール（必要な場合のみ）
            choco install terraform -y | Out-Null
          }
          try {
            terraform init -no-color
            $rid = "/providers/Microsoft.Subscription/aliases/$alias"
            terraform import -no-color azapi_resource.subscription $rid 2>$null
            if ($LASTEXITCODE -ne 0) { Write-Host "terraform import skipped (not critical)." }
          } finally { Pop-Location }

# =========================================================
# Stage1: Resource Group
# =========================================================
- stage: stage1_rg
  displayName: "Stage1 - Resource Group"
  dependsOn: stage0_subscription
  condition: succeeded('stage0_subscription')
  jobs:
  - job: apply_rg
    displayName: "RG作成"
    variables:
      subscriptionIdFromStage0: $[ stageDependencies.stage0_subscription.create_alias.outputs['create_alias.subscriptionId'] ]
      subscriptionAlias:        $[ stageDependencies.stage0_subscription.create_alias.outputs['create_alias.subscriptionAlias'] ]
    condition: and(succeeded(), ne(variables['subscriptionIdFromStage0'], ''))
    steps:
    - checkout: self
    - task: TerraformInstaller@1
      displayName: "Install Terraform"
      inputs:
        terraformVersion: '1.7.5'

    - powershell: |
        $sub = "$(subscriptionIdFromStage0)"
        if ([string]::IsNullOrWhiteSpace($sub)) { throw "subscriptionIdFromStage0 is empty" }
        Write-Host "subscriptionIdFromStage0=$sub"
        Write-Host "subscriptionAlias=$(subscriptionAlias)"
      displayName: "Echo subId (debug)"

    - task: AzureCLI@2
      displayName: "Terraform apply (Stage1 RG)"
      inputs:
        azureSubscription: 'snp-pipeline-api'
        scriptType: ps
        scriptLocation: inlineScript
        inlineScript: |
          $ErrorActionPreference = 'Stop'
          az account set --subscription "$(subscriptionIdFromStage0)"
          Write-Host "Using subscription: $(subscriptionIdFromStage0)"
          $env:ARM_USE_AZCLI_AUTH = "true"
          Push-Location "$(Build.SourcesDirectory)\terraform\stage1-rg"
          try {
            terraform init -no-color
            terraform apply -auto-approve -no-color
          } finally { Pop-Location }

# =========================================================
# Stage2: VNet
# =========================================================
- stage: stage2_vnet
  displayName: "Stage2 - VNet"
  dependsOn:
  - stage0_subscription
  - stage1_rg
  condition: and(succeeded('stage1_rg'), succeeded('stage0_subscription'))
  jobs:
  - job: apply_vnet
    displayName: "VNet作成"
    variables:
      subscriptionIdFromStage0: $[ stageDependencies.stage0_subscription.create_alias.outputs['create_alias.subscriptionId'] ]
    condition: and(succeeded(), ne(variables['subscriptionIdFromStage0'], ''))
    steps:
    - checkout: self
    - task: TerraformInstaller@1
      displayName: "Install Terraform"
      inputs:
        terraformVersion: '1.7.5'

    - powershell: |
        Write-Host "subscriptionIdFromStage0=$(subscriptionIdFromStage0)"
      displayName: "Echo subId (debug)"

    - task: AzureCLI@2
      displayName: "Terraform apply (Stage2 VNet)"
      inputs:
        azureSubscription: 'snp-pipeline-api'
        scriptType: ps
        scriptLocation: inlineScript
        inlineScript: |
          $ErrorActionPreference = 'Stop'
          az account set --subscription "$(subscriptionIdFromStage0)"
          Write-Host "Using subscription: $(subscriptionIdFromStage0)"
          $env:ARM_USE_AZCLI_AUTH = "true"
          Push-Location "$(Build.SourcesDirectory)\terraform\stage2-vnet"
          try {
            terraform init -no-color
            terraform apply -auto-approve -no-color
          } finally { Pop-Location }

    - task: AzureCLI@2
      name: resolve
      displayName: "Export Spoke VNet/RG to output variables"
      inputs:
        azureSubscription: 'snp-pipeline-api'
        scriptType: ps
        scriptLocation: inlineScript
        inlineScript: |
          $ErrorActionPreference = 'Stop'
          az account set --subscription "$(subscriptionIdFromStage0)"
          $dir = "$(Build.SourcesDirectory)\terraform\stage2-vnet"
          Push-Location $dir
          try {
            terraform init -no-color -input=false | Out-Null
            $json = terraform show -json
          } finally { Pop-Location }

          if (-not $json) { throw "terraform show -json returned empty." }
          $obj = $json | ConvertFrom-Json
          $vnet = $obj.values.root_module.resources | Where-Object { $_.type -eq "azurerm_virtual_network" } | Select-Object -First 1
          if (-not $vnet) { throw "No azurerm_virtual_network found in Stage2 state." }

          $spokeVnetName = $vnet.values.name
          $spokeRgName   = $vnet.values.resource_group_name

          if ([string]::IsNullOrWhiteSpace($spokeVnetName) -or [string]::IsNullOrWhiteSpace($spokeRgName)) {
            throw "Failed to resolve Spoke VNet/RG."
          }

          Write-Host "Resolved Spoke: VNet=$spokeVnetName, RG=$spokeRgName"
          Write-Host "##vso[task.setvariable variable=spokeVnetName;isOutput=true]$spokeVnetName"
          Write-Host "##vso[task.setvariable variable=spokeRgName;isOutput=true]$spokeRgName"

# =========================================================
# Stage3: Subnet + NSG + 関連付け
# =========================================================
- stage: stage3_subnet
  displayName: "Stage3 - Subnet"
  dependsOn:
  - stage0_subscription
  - stage2_vnet
  condition: and(succeeded('stage2_vnet'), succeeded('stage0_subscription'))
  jobs:
  - job: apply_subnet
    displayName: "Subnet + NSG + 関連付け"
    variables:
      subscriptionIdFromStage0: $[ stageDependencies.stage0_subscription.create_alias.outputs['create_alias.subscriptionId'] ]
    condition: and(succeeded(), ne(variables['subscriptionIdFromStage0'], ''))
    steps:
    - checkout: self
    - task: TerraformInstaller@1
      displayName: "Install Terraform"
      inputs:
        terraformVersion: '1.7.5'

    - powershell: |
        Write-Host "subscriptionIdFromStage0=$(subscriptionIdFromStage0)"
      displayName: "Echo subId (debug)"

    - task: AzureCLI@2
      displayName: "Terraform apply (Stage3 Subnet)"
      inputs:
        azureSubscription: 'snp-pipeline-api'
        scriptType: ps
        scriptLocation: inlineScript
        inlineScript: |
          $ErrorActionPreference = 'Stop'
          az account set --subscription "$(subscriptionIdFromStage0)"
          Write-Host "Using subscription: $(subscriptionIdFromStage0)"
          $env:ARM_USE_AZCLI_AUTH = "true"
          Push-Location "$(Build.SourcesDirectory)\terraform\stage3-subnet"
          try {
            terraform init -no-color
            terraform apply -auto-approve -no-color
          } finally { Pop-Location }

# =========================================================
# Stage4a: Hub -> Spoke
# =========================================================
- stage: stage4a_peering_hub_to_spoke
  displayName: "Stage4a - Peering Hub → Spoke"
  dependsOn:
    - stage2_vnet
    - stage0_subscription
  condition: succeeded('stage2_vnet')
  jobs:
    - job: peering_hub_to_spoke
      displayName: "Hub → Spoke ピアリング作成"
      variables:
        spokeSubIdFromS0:    $[ stageDependencies.stage0_subscription.create_alias.outputs['create_alias.subscriptionId'] ]
        spokeVnetNameFromS2: $[ stageDependencies.stage2_vnet.apply_vnet.outputs['resolve.spokeVnetName'] ]
        spokeRgNameFromS2:   $[ stageDependencies.stage2_vnet.apply_vnet.outputs['resolve.spokeRgName'] ]
      condition: and(succeeded(),
                     ne(variables['spokeSubIdFromS0'], ''),
                     ne(variables['spokeVnetNameFromS2'], ''),
                     ne(variables['spokeRgNameFromS2'], ''))
      steps:
        - checkout: self
        - task: TerraformInstaller@1
          displayName: "Install Terraform"
          inputs:
            terraformVersion: '1.7.5'

        - powershell: |
            Write-Host "Spoke: sub=$(spokeSubIdFromS0) vnet=$(spokeVnetNameFromS2) rg=$(spokeRgNameFromS2)"
          displayName: "Echo spoke (debug)"

        - task: AzureCLI@2
          displayName: "Terraform apply (Stage4a Hub→Spoke)"
          env:
            ARM_USE_AZCLI_AUTH: 'true'
            TF_VAR_spoke_subscription_id: $(spokeSubIdFromS0)
            TF_VAR_spoke_vnet_name:       $(spokeVnetNameFromS2)
            TF_VAR_spoke_rg_name:         $(spokeRgNameFromS2)
          inputs:
            azureSubscription: 'snp-pipeline-api'
            scriptType: ps
            scriptLocation: inlineScript
            inlineScript: |
              $ErrorActionPreference = 'Stop'
              $hubSub = "7d1f78e5-bc6c-4018-847f-336ff47b9436"
              az account set --subscription $hubSub
              Write-Host "Using subscription (hub): $hubSub"

              if ([string]::IsNullOrWhiteSpace($env:TF_VAR_spoke_subscription_id) -or
                  [string]::IsNullOrWhiteSpace($env:TF_VAR_spoke_vnet_name) -or
                  [string]::IsNullOrWhiteSpace($env:TF_VAR_spoke_rg_name)) {
                Write-Error "Missing TF vars. sub_id='$($env:TF_VAR_spoke_subscription_id)' vnet='$($env:TF_VAR_spoke_vnet_name)' rg='$($env:TF_VAR_spoke_rg_name)'"
              }

              Push-Location "$(Build.SourcesDirectory)\terraform\stage4a-peering-hub-to-spoke"
              try {
                terraform init  -no-color -input=false
                terraform plan  -no-color -input=false
                terraform apply -no-color -input=false -auto-approve
              } finally { Pop-Location }

# =========================================================
# Stage4b: Spoke -> Hub
# =========================================================
- stage: stage4b_peering_spoke_to_hub
  displayName: "Stage4b - Peering Spoke → Hub"
  dependsOn:
    - stage0_subscription
    - stage2_vnet
    - stage4a_peering_hub_to_spoke
  condition: succeeded('stage4a_peering_hub_to_spoke')
  jobs:
    - job: peering_spoke_to_hub
      displayName: "Spoke → Hub ピアリング作成"
      variables:
        subscriptionIdFromStage0: $[ stageDependencies.stage0_subscription.create_alias.outputs['create_alias.subscriptionId'] ]
        spokeVnetNameFromS2:      $[ stageDependencies.stage2_vnet.apply_vnet.outputs['resolve.spokeVnetName'] ]
        spokeRgNameFromS2:        $[ stageDependencies.stage2_vnet.apply_vnet.outputs['resolve.spokeRgName'] ]
      condition: and(succeeded(),
                     ne(variables['subscriptionIdFromStage0'], ''),
                     ne(variables['spokeVnetNameFromS2'], ''),
                     ne(variables['spokeRgNameFromS2'], ''))
      steps:
        - checkout: self
        - task: TerraformInstaller@1
          displayName: "Install Terraform"
          inputs:
            terraformVersion: '1.7.5'

        - powershell: |
            Write-Host "Spoke VNet=$(spokeVnetNameFromS2), RG=$(spokeRgNameFromS2)"
          displayName: "Echo spoke (debug)"

        - task: AzureCLI@2
          displayName: "Terraform apply (Stage4b Spoke→Hub)"
          env:
            ARM_USE_AZCLI_AUTH: 'true'
            TF_VAR_spoke_vnet_name: $(spokeVnetNameFromS2)
            TF_VAR_spoke_rg_name:   $(spokeRgNameFromS2)
          inputs:
            azureSubscription: 'snp-pipeline-api'
            scriptType: ps
            scriptLocation: inlineScript
            inlineScript: |
              $ErrorActionPreference = 'Stop'
              az account set --subscription "$(subscriptionIdFromStage0)"
              Write-Host "Using subscription (spoke): $(subscriptionIdFromStage0)"

              if ([string]::IsNullOrWhiteSpace($env:TF_VAR_spoke_vnet_name) -or
                  [string]::IsNullOrWhiteSpace($env:TF_VAR_spoke_rg_name)) {
                Write-Error "Missing TF vars. vnet='$($env:TF_VAR_spoke_vnet_name)' rg='$($env:TF_VAR_spoke_rg_name)'"
              }

              Push-Location "$(Build.SourcesDirectory)\terraform\stage4b-peering-spoke-to-hub"
              try {
                terraform init  -no-color -input=false
                terraform plan  -no-color -input=false
                terraform apply -no-color -input=false -auto-approve
              } finally { Pop-Location }

        - task: AzureCLI@2
          displayName: "Verify peering exists (spoke-to-hub)"
          inputs:
            azureSubscription: 'snp-pipeline-api'
            scriptType: ps
            scriptLocation: inlineScript
            inlineScript: |
              $ErrorActionPreference = 'Stop'
              az account set --subscription "$(subscriptionIdFromStage0)"
              $state = az network vnet peering show `
                --resource-group "$(spokeRgNameFromS2)" `
                --vnet-name "$(spokeVnetNameFromS2)" `
                --name "spoke-to-hub" `
                --query peeringState -o tsv 2>$null
              if (-not $state) {
                Write-Error "spoke-to-hub peering not found under RG=$(spokeRgNameFromS2) VNet=$(spokeVnetNameFromS2)"
              } else {
                Write-Host "Peering 'spoke-to-hub' state: $state"
              }
